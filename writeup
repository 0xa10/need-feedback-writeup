
  ___            _  ___  
 / _ \__  ____ _/ |/ _ \ 
| | | \ \/ / _` | | | | |
| |_| |>  < (_| | | |_| |
 \___//_/\_\__,_|_|\___/ 
                         
 --[ Table of contents
        1. Intro 
            [Explain about self, motivation, 2-3 lines tops]
            [Explain about writeup and covered topics: mainly linear cryptanalysis]
            [The challenge - Google CTF qualifier 2016 - crypto,
            as of yet no published practical solution (only bruteforce)]
            [Challenge - encrypted communications in pcap, client/server code
            featuring proprietary crypto - LFSRs and Sbox
            [General premise of the attack, with links to technical gists - 
                breaking Sbox, breaking LFSR, etc ]
        2. KappaCrypto
            [General code structure and class heirarachy
                KappaTunnel relaying KappaChannel, KappaMsg -> KappaPacket,
                General KappaCrypto class interface]
            [Seed generation - 2 lines at most.]
            [Cipher design - 
                LFSR(s), Multi-LFSR, Sbox, Stream XOR, make cool graph]
        3. LFSRs - 
            [Brief explanation, usage examples, historical vulnerabilities - DVD crypto (CSS)]
            [Attacking LFSRs - 
                analyzing period, etc, recovering seed from outputs.]
            [Show intuition for recovering seed for n-sized lfsr using n outputs of said LFSR]
            [Linear equation systems and gaussian reduction]
            [LFSR representation using linear algebra]
            [Example - creating linear equation system and solving LFSR using GE]
        4. Multi-LFSRs
            [Brief analysis of Multi-LFSRs, xor as addition mod 2]
            [Example - creating LES for Multi LFSR and solving using GE]
        5. Sbox
            [Brief explanation, only non-linear component]
            [Explain about 6->4 bit mapping and resulting conclusions]
            [Intuition - finding linearity in Sbox - fixed bits]
            [Linear cryptanalysis - the idea - finding additional linear relations between inputs and output]
            [Creating equations from linear relations]
        6. Putting it together - 
            [Each Sbox output provides us with a series of equations we know hold over the cipher system]
            [Generally speaking - for a system with LFSRs with total N bits, N linearly-independant
             equations are required]
            [Guessing keystream bytes - HTTP response headers, upper nibbles of ASCII, etc]
            [Given speculative keystream, we can attempt to solve linear equation system using GE]
            [Example and code demo - (sage?)]
        7. The solution - full code in Python3 and the flag

--[ 1 - Intro
    This writeup will describe how to solve the need-feedback challenge from the 2016 Google CTF "Homework" exercises.
    In a nutshell, in this challenge you are presented with code for a proprietary implementation of an encrypted tunnel, called KappaCrypto.
    A pcap file containing an encrypted HTTP session is also provided, with the flag presumably contained within the encrypted payload.
    
    At the time this challenge was published I was busy polishing my crypto skills, and though I found this challenge very interesting I did not have
    the knowhow to solve it. Two years later - I decided to finally put to work some of my newly acquired knowledge in order to implement a solution for this challenge.
    Big thanks goes out to Bar Katz for introducing me to the mathematical theory and intuition required to tackle this task.

    This challenge remained unsolved during the CTF, and a solution for it was first published by luc-lynx:
    https://github.com/luc-lynx/need_feedback_writeup/blob/master/README.md
    In his solution, he utilized a meet-in-the-middle technique to reduce the keyspace to approx. 2^43. According to the write-up, revealing the 
    key took about 3 days. 

    In my solution, I wanted to reduce the time required to recover the key to an amount of time feasible in the timespan of an average CTF.
    For this, I chose to attack some of the underlying components of the cipher, while employing some principles of linear cryptanalysis.
    This writeup, hopefully, will serve as an intuitive introduction into some more advanced aspects of crypto, including buzzwords such as:
        - Linear feedback shift registers 
        - Linear cryptanalysis
        - Sbox analysis
        - Linear equation systems
        - Gaussian elimination
        - etc

    For those already familiar with some of these concepts who are merely interested in the gist of the solution:
    By finding linear equations that hold over the Sbox, and using known plaintext bytes (HTTP headers) to extract parts of the keystream,
    it is possible to generate enough independent linear equations to solve for each of the initial key state bits.
    For this, we have to accomplish the following sub-tasks:
        1. Recover the original state of an LFSR, given sufficient outputs
        2. Represent the LFSR and the MultiLFSR elements using linear equations.
        3. Analyze the Sbox to find linear equations which hold (are always true) over the Sbox
        4. Collect enough keystream bits based on the HTTP headers, and create an enveloping linear equation system for the whole cipher

--[ 2 - KappaCrypto
    The cipher system presented in the challenge is named KappaCrypto.
    It provides several primitives which eventually come together to create an encrypted tunnel -
    A KappaTunnelHandler class implements an interface for a basic python ThreadedTCPServer.
    Inside the tunnel, a KappaChannel object is instantiated, which processes messages in the
    upstream and downstream channels, wrapping them in KappaMsg objects, and then serializing them
    into KappaPacket objects which are finally sent through the tunnel.

    The encryption takes place prior to wrapping in KappaMsg objects, by using the KappaCrypto
    class, which is where the magic happens:
    Looking at the class, we see several key elements:
        1. 5 sets of LFSR coefficients, representing LFSRs of various bit lengths
        2. An Sbox, represented as a python list - in which sbox_tb[sbox_input] = sbox_output 
        3. a MultiLFSR class, which brings together the five aformentioned LFSRs with the Sbox
    
    Firstly - what is an LFSR?
    https://en.wikipedia.org/wiki/Linear-feedback_shift_register
    We'll go into the nitty gritty of LFSRs in the next section,
    for now suffice it to say that a linear feedback shift register is a simple pseudorandom number generator, which emits a single bit each cycle.
    In KappaCrypto, the LFSR implementation (truncated) looks like this:
        class LFSR:
          def __init__(self, coeffs, n, state=1):
            ...
          def next(self):
            b = self.state >> (self.n - 1)
            ...
            return b
    Generally speaking, a coefficient vector describes a specific LFSR, n describes its length,
    and the state parameter is effectively the seed.
    
    As for the Sbox - a Substition-box is simply a table which takes in values in a given range and 
    outputs values in a given range.
    https://en.wikipedia.org/wiki/S-box
    In KappaCrypto, the Sbox implementation boils down to a simple lookup table:
        class Sbox:
          def __init__(self, tb, nbit_out):
            self.tb = tb
            ...
          def get(self, a):
            return self.tb[a]
    Note that the input and output ranges don't have to be the same - as is the case here - 
    the Sbox takes 6 bit values and outputs 4 bit values.
    We'll get into Sbox details and the KappaCrypto specifics later on, but suffice it to say
    at this point that the Sbox usual role in a cipher is to obstruct and remove linear 
    relationships between the plaintext and ciphertext.
    
    KappaCrypto takes these two basic cryptographic primitives and combines them with 
    the MultiLFSR class, which is the topmost logical unit in KappaCrypto.
    In short, this class takes a list of LFSR instances and one S-box instance, a seed value,
    and outputs random bits from the next() method:
      def next(self):
        if len(self.q) == 0:
          v = 0
          for j in range(self.sbox.nbit_in):
            u=0
            for lfsr in self.lfsrs:
              u ^= lfsr.next()
            v|=u<<j
          v = self.sbox.get(v)
          for i in range(self.sbox.nbit_out):
            self.q.append(v >> i & 1)
        res = self.q[0]
        self.q = self.q[1:]
        return res
    Briefly explained - in each round of the MultiLFSR, a single bit is extracted from
    each of the contained LFSRs, and combined using a combining function (in this case, just XORed).
    This is repeated to obtain n bits, where n is the input size for the Sbox, and the n-bit
    vector is then run through the Sbox to obtain bits to output for the keystream.
    The keystream is then simply XORed against the plaintext bitstream.
    
    The MultiLFSR is seeded by hashing a key and initialization vector (initialized to 0) to generate 
    enough random bits to fill all the LFSR states.
    The KappaCrypto class also supports reseeding, which increments the IV value each time
    without changing the key. Reseeds are meant to be triggered using a specific KappaMsg type,
    but luckily for us, the code indicates that reseeding is actually unimplemented.
      def proc_reseed(self, e):
        assert 0, "unimplemented"
        pass
    
    tl;dr - the cipher is composed from 5 LFSRs with fixed coefficients and one Sbox.
    We have a pcap file which shows recorded HTTP traffic encrypted with KappaCrypto.
    Obviously, we're missing the key. Since the key itself is passed through a hash function,
    there's no hope (or reason) to recover it - finding the state values for each of the LFSRs
    will be enough to recover the whole keystream.
            lfsr_coeffs = [
                [0x0 ,0x1 ,0x2 ,0x3 ,0x6 ,0x9 ,0xa],
                [0x0 ,0x1 ,0x2 ,0x3 ,0x6 ,0x7 ,0x9 ,0xa ,0xb],
                [0x0 ,0x2 ,0x7 ,0x8 ,0xa ,0xb ,0xc],
                [0x0 ,0x1 ,0x3 ,0x7 ,0xa ,0xb ,0xd],
                [0x0 ,0x3 ,0x4 ,0xa ,0xb ,0xc ,0xe],
            ]
            for coeffs in lfsr_coeffs:
              lfsr = LFSR(coeffs, coeffs[-1])
              lfsrs.append(lfsr)
    The 5 LFSRs bit length totals to 60 bits (0xa + 0xb + 0xc + 0xd + 0xe), which means
    we have to recover 60 bits - not feasible for bruteforce.
    
--[ 3. Linear feedback shift registers
    LFSRs are simple PRNG constructs, which are commonly used in hardware applications due to their speed and simplicity.
    Historically, LFSRs have been used (to varying degrees of success) in many ciphers, such as in GSM, Bluetooth, and various digital broadcast mediums.
    Famously, the Content Scramble System, which was used to encrypt DVDs and was implemented using LFSRs, was completely broken partially on account of its 
    use of LFSRs.

    Many types of LFSRs exist, the one we're interested, which most closely resembles the LFSR in KappaCrypto is called a Galois LFSR.
    Generally speaking, a Galois LFSR is simple an n-bit register, which is shifted left at each round. 
    The outgoing bit (the MSB) is the output for that round, and the incoming zero bit is inserted as the new LSB.
    The LFSR also has a coefficient vector, which is simply a series of taps, or indexes to specific bits in the register which are XORed
    with the output bit at each round. 
    
    Example - simple 4 bit LFSR:
    lsb ... msb
    Coefficient vector - 
        0 1 1 0 
    Initial state -     
        0 1 1 1 
              ^ 
        First output bit 

    State after 1 shift, before XOR:
        0 0 1 1, output bit is 1
    XORing with the taps:
        0 0 1 1 +
        0 1 1 0
          ^ ^
        taps
    State after XORing:
        0 1 0 1
    [animate a few more rounds]

    A different way to look at this is - only if the output bit from the LFSRs current round is 1, XOR the state with the coefficient vector. 
    
    Notes regarding KappaCrypto - in KappaCrypto, the coefficient vector is 1 bit longer than the register, with the MSB by definition set to 1.
    This effectively "short-circuits" all outgoing bit - any 1 bit shifted beyond the register size will be zeroed by XORing with the MSB, that way 
    the register is truncated to n-bits at any time the outgoing bit is 1. To account for this, the register has a leading 0
    The coefficient vector is converted to a number and is treated as a polynomial value in KappaCrypto's LFSR implementation - the polynomial is 
    just a number representing the taps as a bit vector, which is then XORed with the state (also a number representing a bit value).
    For the previous example, the coefficients vector is [1,2,4] (or - 22) and the initial state is 14.
    0 1 1 0 1
    0 1 1 1 0
    First round, before XOR:
    0 1 1 0 1
    0 0 1 1 1
    After XOR:
    0 1 0 1 0
    
    The state of each LFSR at any given point is linearly dependant on its previous states. This means that given enough outputs of a
    given LFSR, we will be able to recover the LFSRs state prior to those outputs.
    More concretely - given an LFSR n bits in length, we need n outputs to fully recover its state.
    Before getting into the mathemathical representation of LFSRs and how to solve them, let's observe the intuition for the previous statement:
    Given a 4 bit LFSR and coefficient vector, where a0 is the lsb and a3 is the msb. For convenience, we'll use the fixed 
    coefficient vector from the previous example, though this can easily be generalized for any coefficient vector c0..c3
        0  1  1  0  - coefficient vector
        a0 a1 a2 a3 - state vector (seed)
    The first output of this LFSR would simply be a3. 
    The state vector is then shifted:
        0   a0          a1          a2
    Now lets XOR the taps with the output (a3), to reach the next state:
        0   a0^a3       a1^a3       a2
    Shifted again, the second output from this LFSR would be a2, and state, pre-xor, would be:
        0   0           a0^a3       a1^a3
    Then, XORing the output bits with the taps:
        0   0^a2        a0^a3^a2    a1^a3
    One more time, lets shift and take the MSB as the output - so a1^a3 is our third output, and the state (pre-xor) is:
        0   0           0^a2        a0^a3^a2
    And post XOR:
        0   0^a1^a3     0^a2^a1^a3  a0^a3^a2
    Finally, out fourth output is a0^a3^a2
    So, we have 4 outputs from the LFSR: 
        a3
        a2
        a1^a3
        a0^a2^a3
    If the direction we're headed is clear to you at this point, feel free to skip to Linear equation systems and GE up ahead.
    Now, if we have 4 consecutive outputs from an LFSR with an unknown seed and the same coefficient vector, we know 
    that the first output corresponds to the 4th bit of the state (a3), the second output corresponds to the 3rd bit (a2),
    and the third and fourth outputs correspond respectively to the second bit of the state XORed with the fourth, and 
    the first, third and fourth bits XORed together - or more clearly, with s0..s3 describing outputs from the LFSR:
    Lets say S = s0...s3 = [1,0,1,1]
        a3          = s0 = 1
        a2          = s1 = 0
        a1^a3       = s2 = 1
        a0^a2^a3    = s3 = 1
    Off the bat, we know the values of a2 and a3, and we can assign them to the other two equations to discover their values:
        a3 = 1
        a2 = 0
        a1^a3 = a1^1 = 1 -> a1 = 0
        a0^a2^a3 = a0^0^1 = 1 -> a0 = 0
    So, for the output vector S, the initial state vector a0...a3 is 
        0 0 0 1
    Lets confirm this by running 4 rounds of the LFSR with this seed (also, switching to the leading bit convention used in KappaCrypto
        0 1 1 0 1 - coefficient vector
        0 0 0 1 0 - seed
              ^
              output bit
    After first shift:
        0 0 0 0 1 - output bit was 1, xor with polynomial
        0 1 1 0 1
        ---------
        0 1 1 0 0, shift again:
        0 0 1 1 0 - output bit was 0, dont xor with polynomial, just shift:
        ---------
        0 0 0 1 1 - output bit was 1, xor with polynomial:
        0 1 1 0 1
        ---------
        0 1 1 1 0, shift again:
        0 0 1 1 1 - output bit was 1, and that's four outputs: S = [1 0 1 1]
    
    Many of you may have notices that all of these calculations can be modeled as a simple system of linear equations, modulo 2 (XOR is addition modulo 2)
    a3 = 1 mod 2
    a2 = 0 mod 2
    a1 + a3 = 1 mod 2
    a0 + a2 + a3 = 1 mod 2
    
Linear equation system: 
    An alternative view to represent this in linear algebra is with matrices. Consider the following linear equation system:
    0*a0 + 0*a1 + 0*a2 + 1*a3 = 1 mod 2
    0*a0 + 0*a1 + 1*a2 + 0*a3 = 0 mod 2
    0*a0 + 1*a1 + 0*a2 + 1*a3 = 1 mod 2
    1*a0 + 0*a1 + 1*a2 + 1*a3 = 1 mod 2
    
    If we consider the coefficients to each of the state bits as vectors, those vectors composing a matrix A,
    and the result vector S as a column vector b, we can derive the following matrix equation:
    A*x = b, where
    A = 0 0 0 1   b = 1
        0 0 1 0       0
        0 1 0 1       1
        1 0 1 1       1
    If we simplify this equation with the same intuition as we did before, 
    we can XOR the 3rd row with the 1st row, and the 4th row with the 3rd and 2nd row, also making sure to XOR the b column:
    A = 0 0 0 1   b = 1
        0 0 1 0       0
        0 1 0 0       0
        1 0 0 0       0
    For notation, I'll now reverse this LES (row-wise)
    A = 1 0 0 0   b = 0
        0 1 0 0       0
        0 0 1 0       0
        0 0 0 1       1
    This is called the row-echelon form of the matrix - the identity matrix and the result column.
    Each column in the identity matrix corresponds to a bit - a0..a3, with the final column revealing the value of said bit.
    What we did by simplifying the equation system is analogous to multiplying [A b] by A's inverse (A^-1), resulting in the identity matrix and the result column vector.

    One way of reducing an LES to its row-echelon form is called Gaussian Elimination:
    [animate gaussian elimination on previous equation system]

    So, we saw that given an LFSR, n bits in length, and its coefficient vector, we can generate an equation system comprising n equations, 
    which can be solved given n outputs from said LFSR.
    So, how do we generate the equation system? The intuition demonstrated above can be used to heuristically generate the equation system,
    but for convenience and clarity ahead I'll also show how to employ standard linear algebra to create this system using numpy/MATLAB/sage:
    [Sage/MATLAB code]
    
    
    

https://www.springer.com/gp/book/9783642173417
https://www.iasj.net/iasj?func=fulltext&aId=88499

    
    
    

     
TODO - 
    LFSR and GE animation scripts
    Links in writeup
    Set up references section
