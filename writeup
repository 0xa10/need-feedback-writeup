
  ___            _  ___  
 / _ \__  ____ _/ |/ _ \ 
| | | \ \/ / _` | | | | |
| |_| |>  < (_| | | |_| |
 \___//_/\_\__,_|_|\___/ 
                         
 --[ Table of contents
        1. Intro 
            [Explain about self, motivation, 2-3 lines tops]
            [Explain about writeup and covered topics: mainly linear cryptanalysis]
            [The challenge - Google CTF qualifier 2016 - crypto,
            as of yet no published practical solution (only bruteforce)]
            [Challenge - encrypted communications in pcap, client/server code
            featuring proprietary crypto - LFSRs and Sbox
            [General premise of the attack, with links to technical gists - 
                breaking Sbox, breaking LFSR, etc ]
        2. KappaCrypto
            [General code structure and class heirarachy
                KappaTunnel relaying KappaChannel, KappaMsg -> KappaPacket,
                General KappaCrypto class interface]
            [Seed generation - 2 lines at most.]
            [Cipher design - 
                LFSR(s), Multi-LFSR, Sbox, Stream XOR, make cool graph]
        3. LFSRs - 
            [Brief explanation, usage examples, historical vulnerabilities - DVD crypto (CSS)]
            [Attacking LFSRs - 
                analyzing period, etc, recovering seed from outputs.]
            [Show intuition for recovering seed for n-sized lfsr using n outputs of said LFSR] - seperate to different page
            [Linear equation systems and gaussian reduction]
            [LFSR representation using linear algebra]
            [Example - creating linear equation system and solving LFSR using GE]
        4. Multi-LFSRs
            [Brief analysis of Multi-LFSRs, xor as addition mod 2]
            [Example - creating LES for Multi LFSR and solving using GE]
        5. Sbox
            [Brief explanation, only non-linear component]
            [Explain about 6->4 bit mapping and resulting conclusions]
            [Intuition - finding linearity in Sbox - fixed bits]
            [Linear cryptanalysis - the idea - finding additional linear relations between inputs and output]
            [Creating equations from linear relations]
        6. Putting it together - 
            [Each Sbox output provides us with a series of equations we know hold over the cipher system]
            [Generally speaking - for a system with LFSRs with total N bits, N linearly-independant
             equations are required]
            [Guessing keystream bytes - HTTP response headers, upper nibbles of ASCII, etc]
            [Given speculative keystream, we can attempt to solve linear equation system using GE]
            [Example and code demo - (sage?)]
        7. The solution - full code in Python3 and the flag

--[ 1 - Intro
    This writeup will describe how to solve the need-feedback challenge from the 2016 Google CTF "Homework" exercises.
    In this challenge you are presented with code for a proprietary implementation of an encrypted tunnel, called KappaCrypto.
    A pcap file containing an encrypted HTTP session is also provided, with the flag presumably contained within the encrypted payload.
    
    Back in 2016 when this challenge was posted I did not have the knowhow to tackle this challenge and I decided to make a point out of learning the necessary skills and solving it.
    Big thanks goes out to Bar Katz for introducing me to the mathematical theory and intuition required to tackle this task.

    This challenge remained unsolved during the CTF, and a solution for it was first published by luc-lynx:
    https://github.com/luc-lynx/need_feedback_writeup/blob/master/README.md
    In his solution, he utilized a meet-in-the-middle technique to reduce the keyspace to approx. 2^43. According to the write-up, revealing the 
    key took about 3 days. 

    In my solution, I wanted to reduce the time required to recover the key to an amount of time feasible in the timespan of an average CTF.
    For this, I chose to attack some of the underlying components of the cipher, while employing some principles of linear cryptanalysis.
    This writeup, hopefully, will serve as an intuitive introduction into some more advanced aspects of crypto, including buzzwords such as:
        - Linear feedback shift registers 
        - Linear cryptanalysis
        - Sbox analysis
        - Linear equation systems
        - Gaussian elimination
        - Cold fusion
        - etc

    The general idea is that the cipher design allows an attacker to find linear equations that 
    hold over the cipher, instantly solving all 60 bits of the initial state using just a few 
    bytes worth of keystream - which can be derived based on the underlying HTTP communications.

--[ 2 - KappaCrypto
    The cipher system presented in the challenge is named KappaCrypto.
    It comprises several components and primitives to implement a secure tunnel -
    A KappaTunnelHandler class implements an interface for a basic python ThreadedTCPServer.
    Inside the tunnel, a KappaChannel object is instantiated, which processes messages in the
    upstream and downstream channels, wrapping them in KappaMsg objects, and then serializing them
    into KappaPacket objects which are finally sent through the tunnel.

    The encryption takes place prior to wrapping in KappaMsg objects, by using the KappaCrypto
    class, which has 3 major components:
        1. 5 sets of LFSR coefficients, representing LFSRs of various bit lengths
        2. An Sbox, represented as a python list - in which sbox_tb[sbox_input] = sbox_output 
        3. a MultiLFSR class, which brings together the five aformentioned LFSRs with the Sbox
    
    https://en.wikipedia.org/wiki/Linear-feedback_shift_register
    We'll go into the nitty gritty of LFSRs in the next section,
    LFSR stands for linear feedback shift register, and is a simple pseudorandom number generator, which emits a single bit each cycle.
    
    As for the Sbox - a Substition-box is simply a table which takes in values in a given range and 
    outputs values in a given range.
    https://en.wikipedia.org/wiki/S-box
    In KappaCrypto, the Sbox implementation boils down to a simple lookup table:
        class Sbox:
          def __init__(self, tb, nbit_out):
            self.tb = tb
            ...
          def get(self, a):
            return self.tb[a]
    Note that the input and output ranges don't have to be the same - as is the case here - 
    the Sbox takes 6 bit values and outputs 4 bit values.
    We'll get into Sbox details and the KappaCrypto specifics later on, but suffice it to say
    at this point that the Sbox usual role in a cipher is to obstruct and remove linear 
    relationships between the plaintext and ciphertext.
    
    KappaCrypto takes these two basic cryptographic primitives and combines them with 
    the MultiLFSR class, which is the topmost logical unit in KappaCrypto.
    In short, this class takes a list of LFSR instances and one S-box instance, a seed value,
    and outputs random bits from the next() method:
      def next(self):
        if len(self.q) == 0:
          v = 0
          for j in range(self.sbox.nbit_in):
            u=0
            for lfsr in self.lfsrs:
              u ^= lfsr.next()
            v|=u<<j
          v = self.sbox.get(v)
          for i in range(self.sbox.nbit_out):
            self.q.append(v >> i & 1)
        res = self.q[0]
        self.q = self.q[1:]
        return res
    Briefly explained - in each round of the MultiLFSR, a single bit is extracted from
    each of the contained LFSRs, and combined using a combining function (in this case, just XORed).
    This is repeated to obtain n bits, where n is the input size for the Sbox, and the n-bit
    vector is then run through the Sbox to obtain bits to output for the keystream.
    The keystream is then simply XORed against the plaintext bitstream.
    
    The MultiLFSR is seeded by hashing a key and initialization vector (initialized to 0) to generate 
    enough random bits to fill all the LFSR states.
    The KappaCrypto class also supports reseeding, which increments the IV value each time
    without changing the key. Reseeds are meant to be triggered using a specific KappaMsg type,
    but luckily for us, the code indicates that reseeding is actually unimplemented.
      def proc_reseed(self, e):
        assert 0, "unimplemented"
        pass
    
    tl;dr - the cipher is composed from 5 LFSRs with fixed coefficients and one Sbox.
    We have a pcap file which shows recorded HTTP traffic encrypted with KappaCrypto.
    Obviously, we're missing the key. Since the key itself is passed through a hash function,
    there's no hope (or reason) to recover it - finding the state values for each of the LFSRs
    will be enough to recover the whole keystream.
            lfsr_coeffs = [
                [0x0 ,0x1 ,0x2 ,0x3 ,0x6 ,0x9 ,0xa],
                [0x0 ,0x1 ,0x2 ,0x3 ,0x6 ,0x7 ,0x9 ,0xa ,0xb],
                [0x0 ,0x2 ,0x7 ,0x8 ,0xa ,0xb ,0xc],
                [0x0 ,0x1 ,0x3 ,0x7 ,0xa ,0xb ,0xd],
                [0x0 ,0x3 ,0x4 ,0xa ,0xb ,0xc ,0xe],
            ]
            for coeffs in lfsr_coeffs:
              lfsr = LFSR(coeffs, coeffs[-1])
              lfsrs.append(lfsr)
    The 5 LFSRs bit length totals to 60 bits (0xa + 0xb + 0xc + 0xd + 0xe), which means
    we have to recover 60 bits - not feasible for bruteforce.
    
--[ 3. Linear feedback shift registers, linear equation systems
    LFSRs are simple PRNG constructs, which are commonly used in hardware applications due to their speed and simplicity.
    Historically, LFSRs have been used (to varying degrees of success) in many ciphers, such as in GSM, Bluetooth, and various digital broadcast mediums.
    Famously, the Content Scramble System, which was used to encrypt DVDs and was implemented using LFSRs, was completely broken partially on account of its 
    use of LFSRs.

    Many types of LFSRs exist, the one we're interested, which most closely resembles the LFSR in KappaCrypto is called a Galois LFSR.
    In KappaCrypto, the LFSR implementation is of a Galois LFSR, it looks like this:
        class LFSR:
          def __init__(self, coeffs, n, state=1):
            (truncated)
          def next(self):
            b = self.state >> (self.n - 1)
            (truncated) 
            return b
    The LFSR is initialized with a coefficient, of n bit-length,
    and the state parameter is effectively the seed.
    The outgoing bit (the MSB) is the output for that round, and the incoming zero bit is inserted as the new LSB.
    
    The coefficient vector marks "taps" on the LFSR, which are XORed with the output bit in 
    each cycle.
    
    Example - simple 4 bit LFSR:
    lsb ... msb
    Coefficient vector - 
        0 1 1 0 
    Initial state -     
        0 1 1 1 
              ^ 
        First output bit 
    State after 1 shift, before XOR:
        0 0 1 1, output bit is 1
    XORing with the taps:
        0 0 1 1 +
        0 1 1 0
          ^ ^
        taps
    State after XORing:
        0 1 0 1
    [animate a few more rounds]

    The state of any LFSR at any given point is linearly dependant on its previous states. This means that given enough outputs of a
    given LFSR, we will be able to recover the LFSRs state prior to those outputs.
    More concretely - given an LFSR n bits in length, we need n outputs to fully recover its state.
    
    For more information how this is accomplished you can see the appendix about LSFRs and
    linear equation systems.
    I ported over some of the concepts seen here:
    https://www.iasj.net/iasj?func=fulltext&aId=88499
    to apply to the LFSR as its implemented in this challenge.
    The following function takes a coefficient vector and returns a set of equations
    for count consecutive outputs. You could multiply this matrix with the initial state
    to get a vector containing 'count' output bits starting from that state.
        def get_lfsr_equations(coeff, count):
            m = np.hstack((np.zeros((n, 1)), np.eye(n)[:,:n-1]))
            coeff_m = np.vstack((np.zeros((n-1, n)), coeff))
            tmp = np.eye(n)
            C = []
            for i in range(count):
                C.append(tmp[:,n-2])
                tmp = (tmp@m + tmp@m@coeff_m) % 2
            return np.matrix(C).transpose()[:n-1,:]
    To clarify - each "equation" in this matrix represents a linear combination of some of 
    the registers bits. Its an expansion of the LFSRs coefficient vector over several 
    iterations of the LFSR.
    
    [Example of output]
    
     
--[ 4. Multi-LFSRs - LES cont.
    As seen earlier, KappaCrypto has a class named MultiLFSR which combines the output of
    all the LFSRs it contains (a Geffe generator?) and then puts them through an Sbox.
    
    In KappaCrypto, the LFSR outputs are XORed together to combine them - which is essentially
    addition modulo 2. As such, we can just add together our equations by stacking them
    horizontally, and add the results vectors for those equations to end up with a valid
    equation set.
    
    For instance, lets assume we have the following LFSRs in our MultiLFSR:
    A = a0 a1 a2 a3 - state vector          B = b0 b1 b2 b3 b4 b5
    C = 0  1  1  0                          C = 1  0  1  1  0  1
    
    Using the code from before, we'll generate equations for each of these. Taking the 3rd
    equations as an example:    
    equations_A[3]: 1 1 0 0 - > 
        a0 + a1 = output_A[3]
    equations_B[3]: 0 0 1 0 1 0 -> 
        b2 + b4 = output_B[3]
    It stands to reason that since we add up the outputs, adding up the equations also holds:
        equations_A[3] + equations_B[3] = a0 + a1 + b2 + b4 = output_A[3] + output_B[3]
    
    Conceptually, we're just introducing more variables to our system, so we'll need more
    outputs from the MultiLFSR to solve.
    Given a MultiLFSR with several LFSRs of arbitrary lengths, we need N outputs to solve 
    for the origianl seed, N being the total bit length of all the contained LFSRs.
    
    So, if we stack our equations to represent addition of all LFSR outputs, we can come up
    with a linear equation system
    [example of solving the example MultiLFSR given 10 outputs]

    Before diving into the Sbox, I'd like to show how all of this would apply to KappaCrypto
    had it NOT passed the outputs from the MultiLFSR through the Sbox.
    Lets use the coefficient values from Kappa and generate enough outputs to solve
    for the original seeds, this time using gaussian elimination.
    [Example of solving the Kappa MultiLFSR given 60 outputs]
     
--[ 5. Substition boxes - linear cryptanalysis
    Sboxes take in some set of input bits (of a fixed length) and substitute them with a set
    of output bits (also of a fixed, but not necessarily same length).
    
    In KappaCrypto, the Sbox is implemented as a list with 64 (2^6) elements, which contain 
    values between 0-15 (2^4) - so it maps between 6 bit values and 4 bit values.
    If you observe the list, each value repeats 4 times - to account for the 2 bit disparity.
    Simply speaking, it means that given a certain output, there are 4 different inputs
    that could have led to that output.
    
    Since the mapping is arbitrary and lossy, there isn't necessarily a linear relation between 
    said input bits and output bits. 
    In fact, the purpose of the Sbox in a cipher such as KappaCrypto is to reduce linearity, 
    preventing us from employing linear equation systems to solve our LFSR.

    Before passing through the Sbox, every 6 bits of output from the MultiLFSR (each bit being
    a linear combination of all the contained LFSRs output) would provide us with 6 equations
    representing the linear relation between the original state and the output.
    However, the same 6 bits are now used to lookup an alternative, 4 bit value.
    Since each one of those 4 bit values could have originated from 4 different inputs, we 
    cannot tell what the LFSRs output was based on the keystream - at least not naively.
    
    In order to attack this component of the cipher we need to find linear equations that 
    hold over the Sbox, i.e. "survive" being passed through the Sbox.
    To accomplish this, we need to take a closer look at the Sbox's inputs and outputs, on 
    the bit level. 
    More concretely, given a 4 bit output from the Sbox, we want to look at all four possible 6 
    bit inputs, and try to find any linear equation that holds over all of these inputs.
    
    We'll start off with an intuitive example, working on the Sbox from KappaCrypto:
        sbox_tb = [ 7, 6, 5, 10, 8, 1, 12, 13, 6, 11, 15, 11, 1, 6, 2, 7, 0, 2,
                    8, 12, 3, 2, 15, 0, 1, 15, 9, 7, 13, 6, 7, 5, 9, 11, 3, 3,
                    12, 12, 5, 10, 14, 14, 1, 4, 13, 3, 5, 10, 4, 9, 11, 15, 10,
                    14, 8, 13, 14, 2, 4, 0, 0, 4, 9, 8,]
    First, we want to reverse the Sbox to see which outputs are caused by which inputs:
        rev_sbox_tb = defaultdict(list)
        for idx, value in enumerate(sbox_tb):
            rev_sbox_tb[value].append(idx)
        rev_sbox_tb
        defaultdict(list,
            {7: [0, 15, 27, 30],
             6: [1, 8, 13, 29],
             ... (truncated)
             14: [40, 41, 53, 56],
             4: [43, 48, 58, 61]})
    Taking 7 as an example - this value substitutes 0, 15, 27 and 30, lets look at their
    binary representation:
        print("\n".join(bin(i)[2:].zfill(6) for i in rev_sbox_tb[7]))
        000000
        001111
        011011
        011110
        
    Looking at each of the bits in each of the inputs, we see the following things:
        - In bits 2, 4, 5, 6 of each of the values, theres an even occurence of 0 and 1 bits.
        - In bit 3, 0 only occurs once, and 1 occurs 3 times.
        - In bit 1 - only 0 bits occur.
    This shows a significant bias in the Sbox. For now, we're only going to address bit 1 of 
    each of the inputs, since it happens to be 0 for 100% of the Sbox inputs for that value.

    Now, given this new information, lets say we see the Sbox output a value of 7. 
    We know that the inputs that lead to this value were either 0, 15, 27, or 30. 
    But we know for certain that the first (most significant) bit of whatever the input was - 
    is 0.
    We also know that bit 3 was more likely to be 1 than 0, but we'll ignore this for now
    since it complicates our solution.

    Another example, this time for Sbox output value 14 - 
        print("\n".join(bin(i)[2:].zfill(6) for i in rev_sbox_tb[14]))
        101000
        101001
        110101
        111000
    Here, bits 1 and 5 are the same in each of the inputs, and 75% bias exists in bits 3 and 4.
    
    If we do this for all Sbox outputs we'll find that almost each Sbox output leaks information
    about input bits, with 100% certainty.
    This alone could be enough to generate enough linear equations, but we can extract even
    more linear information using a more generalized approach.
        
    This approach is akin to linear cryptanalysis as its described here, except we omit use
    of the statistical components and use only 100% biases in certain bits.
    [find paper]
    
    Essentially, we again take all 4 inputs for a given Sbox output, and check which
    linear combination of bits leads to uniform results among all 4 inputs.
    For instance, again looking at the example for Sbox output 14:
        print("\n".join(bin(i)[2:].zfill(6) for i in rev_sbox_tb[14]))
        101000
        101001
        110101
        111000
    Lets combine (add mod 2 i.e. xor) bits 1, 3 and 4 in each of these outputs:
        101000 - 1 + 1 + 0 = 2 mod 2 = 0
        101001 - 1 + 1 + 0 = 2 mod 2 = 0
        110101 - 1 + 0 + 1 = 2 mod 2 = 0
        111000 - 1 + 1 + 0 = 2 mod 2 = 0
        ^ ^^     
        101100 - (the mask)
    This allows us to collect additional information from each Sbox output - 
    if the Sbox outputs 14, no matter which of the four possible inputs 
    was responsible for it - we know that the sum (mod 2) of bits 1, 3 and 4 was 0 - 100%
    of the times.
    And of course, each one of those bits (i.e. combined LFSR outputs) can be represented as 
    a linear equation of the initial LFSR states.
    The sum of these equations can be represented by adding the equations mod 2 - i.e. XORing 
    them.
    More concretely - if we apply the mask 101100 to all 4 inputs, and then sum the bits
    of each of those inputs, the result will be 0 100% of the time.
    
    To map all such biases in the Sbox, we'll do the following:
        for each Sbox output, map the four relevant 6 bit inputs:
            for each possible 6 bit mask (2^6 values), 
            apply the mask to all four input values, and sum their bits.
            If the results are the same for all four input values, we have found
            a valid equation which holds over the Sbox.

    
    

    

    
    
    
     
    

https://www.springer.com/gp/book/9783642173417
https://www.iasj.net/iasj?func=fulltext&aId=88499

    
    
    

     
TODO - 
    LFSR and GE animation scripts
    Links in writeup
    Set up references section
    Replace get_lfsr_equations with either MATLAB or sage code.
